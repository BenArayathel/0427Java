Differences bt Collection and Collections?
    Collection is an interface; Collections is a class.
    Collection provides standardard functionality of data structures to List/Set/Queue; Collections used to sort and synchronize the collection elements.
    Collection provides methods used for data structures; Collections provides static methods used for various operations on a collection.

Differences bt collection and array?
    Arrays are always of fixed size.
    Arrays can only store same data types.

Differences bt ArrayList and Vector?
    ArrayList isn't synchronized, and therefore is not thread-safe.
    Vectors are thread-safe because its methods are synchronized.
    Vector is a legacy class.

Differences bt ArrayList and LinkedList?
    ArrayList uses a dynamic array; LinkedList uses a doubly linked list. (?)
    ArrayList better for storing and fetching; LinkedList better for manipulation.
    ArrayList provides random access; LinkedList does not provide random access.
    ArrayList has less memory overhead bc it stores only objects; LinkedList take more bc it stores object AND their address.

Differences bt Iterator and ListIterator?
    Iterator traverses forward only; ListIterator is bidirectional.
    Iterator can be used in List/Set/Queue; ListIterator used in List only.
    Iterator can only perform remove while traversing; ListIterator can perform add/remove/and set.

Differences bt List and Set?
    List can contain duplicates; Set cannot contain duplicates.
    List maintains insertion order; Set does not maintain insertion order.
    List contains the legacy Vector class; Set does not have any legacy classes.
    List allows multiple null values; Set allows only a single null value.

Differences bt Comparable and Comparator?
    Comparable provides one sort of sequence; Comparator provides multiple sorts of sequences.
    Comparable provides compareTo(); Comparator provides compare().
    Comparable found in java.lang; Comparator found in java.util.
    If we implement Comparable interface, the actual class is modified; if we implement Comparator, the actual class isn't changed.

Why override .equals()?
    Normally, equals() checks whether two objects are same or not.
    We override it if we want to check if objects based on the property.
    Example:
        Employee is a class that has 3 data members: id, name, and salary.
        However, we want to check the equality of employee object by the salary.
        Then, we need to override the equals() method.
