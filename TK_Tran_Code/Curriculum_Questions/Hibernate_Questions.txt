Explain the importance of the Hibernate F/w
	Reduces lines of code by maintaining object-table mappings itself and returns results to an application in the form of Java objects.
	Created by Gavin King.
JPA Vs Hibernate
	JPA (Java Persistence API) is a specification; Hibernate implements this specification.
	I.e. JPA is the dance, Hibernate is the dancer.
JDBC vs Hibernate
	JDBC is an API used to communicate with the database.
	Hibernate is an ORM which is used to map POJOs to corresponding relational database tables.
	ORM advantages: app development is fast, management of transactions is easy, details of SQL queries are hidden.
Builder Pattern in Hibernate
	An object-construction pattern that suggests moving the construction logic out of the object class to a separate class (a builder class).
Factory Pattern in Hibernate
	A creational pattern that suggests creating objects without having to specify the exact class of that object.
	Instead, create objects by invoking a "factory method":
		An interface and implemented by child classes or,
		Implemented in a base class and optionally overridden by derived classes
	..rather than by calling the class' constructor itself.
Fetch Strategies in Hibernate
	Relationships are defined through JOINS in a DB. Hibernate represents these JOINS in the form of
		associations/relationships (One-to-One, One-to-Many, Many-to-Many). It's required to define FetchType when you use any associations.
	FetchType.LAZY - fetches child entities lazily (ONLY WHEN you specify it to).
		Improves performance by avoiding unnecessary computation and reduces memory requirements.
	FetchType.EAGER - fetches parent entities along with their children entities (fetch it ALL so you'll have it when you need it).
		More memory consumption and slow processing speeds.
	Pro-tip: All "to-one" relationships use EAGER; all "to-many" relationships use LAZY.
	Default is EAGER.
load() vs get()
	get() returns data directly, load() returns a proxy object.
	get() returns NULL if the record isn't found; load() throws an EXCEPTION.
save() vs persist()
	save() returns an identifier generated by the DB.
	persist() doesn't return anthing; it's return type is void.
save() vs saveOrUpdate()
	save() does an INSERT to store the object into the DB and also returns the identifier generated by the DB.
	saveOrUpdate() can do INSERT or UPDATE depending upon whether the object already exists in the DB or not.
		Slower since it needs extra processing power to find out whether a record exists or not.
what is HQL?
	Hibernate Query Language; similar in appearance to SQL but is fully object-oriented and understands notions like inheritance, polymorphism, and association.
HQL vs SQL
Core Hibernate Interfaces
	1. Configuration (I) - uses hibernate.cfg.xml to create a SessionFactory.
		Configuration cfg = new Configuration();
		cfg.addResource("hello/Message.hbm.xml");
		cfg.setProperties( System.getProperties() );
	2. Transaction (I) - OPTIONAL, used to commit and rollback changes to the state of persistent data.
		Transaction transaction = session.beginTransaction();
	3. SessionFactory (I) - a Factory used to create Session instances; lightweight and typically only one instance is created for entire application; THREAD SAFE.
		SessionFactory sessionFactory = cfg.buildSessionFactory();
	4. Session (I) - a persistence manager that manages operations like storing and retrieving objectsl; NOT THREAD SAFE.
		Session session = sessionFactory.openSession();
	5. Query and Criteria Interface - allows you to perform queries against the DB and controls filtration of queries, respectively.
different states of an object in hibernate
	Transient - an object not associated with a session and does not represent a row in the DB.
		Employee emp = new Employee();
		emp.setName("Ravi Raj");
		// emp object is in a transient state
	Persistent - an object associated wtih a session; when in this state, the object represents one DB row and consists of an identifier value.
		Long id = (Long) session.save(emp);
		// emp object is now in a persistent state
	Detached - an object just removed from a session; it still contains an identity but you can't do persistence operations with that identity.
		session.close();
		//object in detached state
what is n+1 problem with hibernate?
	A performance issue related to persistence.
	Occurs when code needs to load the children of a parent-child relationship (the "many" in "one-to-many").
	Most ORMs have lazy-loading enabled by default, so queries are issued for the parent record, and then one query for EACH child record (INEFFICIENT).
Contextual Sessions in Hibernate
	The mapping of a current Session to a user's context.
L1 Vs L2 cache
	L1 is cache memory built onto the CPU itself.
		Associated with SESSION; exists per session.
		ENABLED BY DEFAULT.
	L2 is cache memory on a separate chip that can be accessed more quickly than the larger "main" memory.
		Associated with SESSIONFACTORY.
		NOT ENABLED BY DEFAULT.
different inheritance mapping in hibernate
	MappedSuperclass – the parent classes, can't be entities.
	Single Table – the entities from different classes with a common ancestor are placed in a single table.
	Joined Table – each class has its table and querying a subclass entity requires joining the tables.
	Table-Per-Class – all the properties of a class, are in its table, so no join is required.
dirty checking in hibernate
	Hibernate automatically detects whether an object is modified or not and in need of being updated.
	Uses a strategy called "inspection"; when an obj is loaded from DB, a snapshot of it is kept in memory.
	When the session is flushed, Hibernate compares the stored snapshot with the current state.
	If they differ, the object is marked DIRTY and a suitable SQL command is enqueued.
different ways of doing association mapping in hibernate
	One-to-One
	One-to-Many
	Many-to-One
	Many-to-Many
what is ORM
	Programming technique for converting data between relational databases and object-oriented programming languages.
what is OGM
	A persistence engine providing JPA support for NoSQL datastores.
what is hbm2ddl auto?
	A Hibernate configuration file used to validate and export schema DDL to the DB when the SessionFactory is created.
	Possible values for hbm2ddl.AUTO:
		create - hibernate first drops the existing tables data and structure, then creates new tables and executes operations on the new table.
		validate - hibernate validates table structure, whether tables and columns exist or not. If table doesn't exist, Hibernate throws exception.
		update - hibernate creates table or column if they don't exist, updates them if they do exist. Different from create b/c no tables get dropped.
		create-drop - used for unit-testing; Hibernate checks for a table to do operations. DROPS THE TABLE AFTER OPERATIONS ARE COMPLETED.
Explain hibernate.cfg.xml
	A Hibernate config file that specifies required Hibernate properties.
	By default, placed under src/main/resource folder.
	Contains database- and session-related configurations.
		Database configs include JDBC connection URL, DB user credentials, driver class, and Hibernate dialect.
Annotations used in Hibernate
	@Entity - marks an entire CLASS as an entity bean, so it MUST have a no-args constructor that's visible with at least protected scope.
	@Table - specifies details of the table that'll be used to persist the entity in the DB.
	@Id and @GeneratedValue - Id specifies the primary key; GeneratedValue makes code portable between different databases.
	@Column
What is dialect
	Hibenate is database-agnostic, so we must specify a dialect to distinguish between which SQL variant we're using.
	A property of hibernate.cfg.xml that generates the appropriate SQL "variant" for the chosen database.
Explain need of Criteria and Restrictions API in hibernate
	Hibernate Criteria API allows you to build up a criteria query object programmatically; the org.hibernate.Criteria interface defines available methods.
	Hibernate Criteria - uses restriction/filtration to selectively retrieve objects.
		E.g retrieve only products with a price over $30.