General Stuff
	src - folder that contains human-readable code; .java
	bin - folder that contains binary (compiled files) that the JVM executes; .jar, .class

Wrapper Classes
    Wrap around primitive data types.
    Turns primitives into Objects:
        boolean > Boolean
        int > Integer
        char > Character
        byte > Byte
        short > Short
        long > Long
        double > Double
    Why?
        Objects have methods assocaited with them.
        Data structures like the Collection API.

        Primitives are still faster than wrappers.
        Only use wrapper when a method needs to accept an Object.
Recall:
	Everything within Main(), will go onto the stack for execution.
	Everything instance-level will go onto the heap.

String
	An object that contains an array of characters.
	Allows creation and manipulation of strings (notice lowercase).
	Immutable: Strings can't be changed.
	Final: The class cannot be extended.
	String objects are stored on heap, but String Literals are stored in String pool,
		which itself is within heap memory.

StringBuilder
	Mutable, more efficient (faster) than StringBuffer.

StringBuffer
	Also mutable, but thread safe/synchronized.
	Lower efficiency (slower) than StringBuffer; it's gotta wait for other threads before continuing.

RegEx (Regular Expression)
	An expression commonly used across programming languages; minor syntax changes.
	PMA - Pattern Matching Algorithm
	[] - expression
	{} - length
	^ - not
	? -
	. -
	* -
	() -
	Examples:
		[a-z]{5} - "any lowercase letter of length 5"
		[0-9]{1,} - "at least 1 digit and max can be any"
		[a-zA-Z0-9]{10} = "any alphanumeric word of length 10"
		[^a-zA-Z0-9] - "apart from alphanumeric" (anything except alphanumeric)

Exceptions
	Exception: anything disrupting the flow of an application.
	Exception-handling determines the quality of an application.

	Separations of Concerns Normal Workflow
	Client/Users/Apps >
		Tier 1: Presentation Layer
			Logic
			Accepts user input
		Tier 2: Business/Application Layer
			Logic
			Checks and validates user input
			Pre-filter, preliminary checks before consulting DB
		Tier 3: Persistance/DB Layer
			Logic
			Interacts with database
	> Database, SQL, NoSQL, PL/SQL

	Object >
		Throwable (all exceptions throwable) >
			Exception (Checked Exception) >
			- SQLException
			- ClassNotFoundException
			- ParseException
			- IOException
				RuntimeException (Unchecked Exceptions), compiler forces dev to handle it
				- ArithmeticException (DivideByZero)
				- IndexOutOfBoundsException
				- ConcurrentModificationException

	try..catch..finally
		try - suspected code that might throw an exception
		catch - handler of exception
		finally - last block; runs regardless of whether exception was handled or not
	throws
		Tosses exception back to previous layer
	throw
		Explicitly create an exception with my own message

	When an exception thrown at runtime, JVM creates exception Object with a predefined message.
		Then, it checks if the dev has handled it.

Serialization
	Serialization is the process of converting a Java Object into a byte stream,
	to transfer it from one JVM to another and recreate it via deserialization.

	For an object to be serializable:
		The parent class must implement the Serializable interface.
		All vars in class must be serializable; mark transient if you don't want it to be.

	When implementing Serializable, must generate a seriazable ID.

	ObjectOutStream used to serialize an object.
		FileOutputStream used for writing byte data to a File.
		For writing character streams, use FileWriter.

	ObjectInputStream used to deserialize an object.
		FileInputStream used for reading byte data from a File.
		For reading character streams, use FileReader.

	Why?
		To save/persist state of an object.
		To travel an object across a network.
		Serialized data streams support encryption compression, authentication, and secure Java computing.
		Many critical technologies rely on serialization.

Comparable vs Comparator (Sorting)
	Comparable
		A class must implement java.lang.Comparable interface to compare its instances.
		A comparable object is capable of comparing itself with another object.

Collections Framework
	Gives devs access to prepackaged data structures and algorithms for manipulating them.
	All collections derive from Java.util package.
	ONLY ACCEPTS OBJECTS.
	CRUD: Create, Read, Update, Delete
		Arrays are slow; must iterate through entire thing to CRUD.
		Easier in collections, no need to iterate through.
	Dynamic and Resizeable
		Memory increase/decrease based on elements added/removed.
	All collections by default iterable.
	Helps us design data structures in an easier way
		Queue, Dequeue, Map, Set, List.

	Collection is the root for all data structures
	Collections is a utility class (helper class) that contains methods like sort(), shuffle(), binarySearch(), reverse().

Design Patterns
    Language agnostic solutions to common problem scenarios.
    Allows for more reusable and maintainable code.
    Creational Design Patterns
        Meant to resolve issues w/ creating objects in a system.
        Singleton:
        Factory: 
    Structural Design Patterns
        Focuses on how classes and objects can be composed.
        Identifies simplest way to realize relationships bt entities.
        Adapter: 
    Behavioral Design Patterns
        Deals with how objects interact; how they communicate w/ each other.
        To achieve simpler formats of comms.
        Chain of Responsibility: 

Multithreading
    Thread: a single process of execution; shares resources within the core its in.
    Multithreading: running multiple threads in parallel.

    Main Thread
        Child threads will be spawned from it.
        Will be the last thread to finish execution; once it stops, the program stops.
    
    Daemon Thread
        Thread always running in the background.
        E.g., Garbage Collection
    
    User Threads
        Can be started and closed.

    Two ways to make custom threads:
        1. Implementing Runnable interface
            Can extend another class while also implementing runnable.
            Also has less overhead, you don't get unnecessary methods.
        2. Extending Thread class
            Less lines of code to "start".
            Easier to override functionality of the Thread class.
    
    States of a Threads = New > Runnable > Running > Waiting > Dead
        New: the thread is instantiated.
        Runnable: start() has been invoked, but the schedular hasn't selected it to start running.
        Running: scheduler has selected it to run.
        Waiting, Time Waiting, Blocked: the thread is alive, but not currently running.
        Dead: thread has been terminated.
    
    Common Thread Problems
        Synchronization
            When threads are utilizing the same resource, e.g. modifying a data structure, 
            errors will occur bc changes will occur to the resource in separate threads.
        Deadlock
            When multiple threads are trying to access the same resource.
        Producer-Consumer (will go over this in class)
            Producer produces resources for another thread, via storing it in a buffer.
            Consumer consumes resource and removes it from the buffer.
            Error occurs if:
                Producer continually produces and consumer never consumes.
                Consumer tries to consume but there's nothing in the buffer to consume.

Maven
    Maven is a dependency manager; allows integration of external libraries and packages.
    What's a dependency?
        External standalone program that we'll utilize in our project.
    POM: Project Object Model, formatted as an XML file containing all config details for Maven project.